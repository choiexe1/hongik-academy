// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: evaluations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEvaluationsByStudent = `-- name: CountEvaluationsByStudent :one
SELECT COUNT(*) FROM evaluations e
WHERE e.student_id = $1
    AND ($2::text IS NULL OR e.content ILIKE '%' || $2::text || '%')
    AND ($3::date IS NULL OR e.created_at::date >= $3::date)
    AND ($4::date IS NULL OR e.created_at::date <= $4::date)
`

type CountEvaluationsByStudentParams struct {
	StudentID int32       `json:"student_id"`
	Search    pgtype.Text `json:"search"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) CountEvaluationsByStudent(ctx context.Context, arg CountEvaluationsByStudentParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEvaluationsByStudent,
		arg.StudentID,
		arg.Search,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvaluation = `-- name: CreateEvaluation :one
INSERT INTO evaluations (student_id, author_id, content)
VALUES ($1, $2, $3)
RETURNING id, student_id, author_id, content, created_at, updated_at
`

type CreateEvaluationParams struct {
	StudentID int32  `json:"student_id"`
	AuthorID  int32  `json:"author_id"`
	Content   string `json:"content"`
}

func (q *Queries) CreateEvaluation(ctx context.Context, arg CreateEvaluationParams) (Evaluation, error) {
	row := q.db.QueryRow(ctx, createEvaluation, arg.StudentID, arg.AuthorID, arg.Content)
	var i Evaluation
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.AuthorID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvaluation = `-- name: DeleteEvaluation :exec
DELETE FROM evaluations WHERE id = $1
`

func (q *Queries) DeleteEvaluation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEvaluation, id)
	return err
}

const getEvaluationByID = `-- name: GetEvaluationByID :one
SELECT e.id, e.student_id, e.author_id, e.content, e.created_at, e.updated_at, u.name as author_name, s.name as student_name
FROM evaluations e
JOIN users u ON e.author_id = u.id
JOIN students s ON e.student_id = s.id
WHERE e.id = $1
`

type GetEvaluationByIDRow struct {
	ID          int32              `json:"id"`
	StudentID   int32              `json:"student_id"`
	AuthorID    int32              `json:"author_id"`
	Content     string             `json:"content"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	AuthorName  string             `json:"author_name"`
	StudentName string             `json:"student_name"`
}

func (q *Queries) GetEvaluationByID(ctx context.Context, id int32) (GetEvaluationByIDRow, error) {
	row := q.db.QueryRow(ctx, getEvaluationByID, id)
	var i GetEvaluationByIDRow
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.AuthorID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorName,
		&i.StudentName,
	)
	return i, err
}

const listEvaluationsByStudent = `-- name: ListEvaluationsByStudent :many
SELECT e.id, e.student_id, e.author_id, e.content, e.created_at, e.updated_at, u.name as author_name
FROM evaluations e
JOIN users u ON e.author_id = u.id
WHERE e.student_id = $1
    AND ($4::text IS NULL OR e.content ILIKE '%' || $4::text || '%')
    AND ($5::date IS NULL OR e.created_at::date >= $5::date)
    AND ($6::date IS NULL OR e.created_at::date <= $6::date)
ORDER BY e.created_at DESC
LIMIT $2 OFFSET $3
`

type ListEvaluationsByStudentParams struct {
	StudentID int32       `json:"student_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Search    pgtype.Text `json:"search"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type ListEvaluationsByStudentRow struct {
	ID         int32              `json:"id"`
	StudentID  int32              `json:"student_id"`
	AuthorID   int32              `json:"author_id"`
	Content    string             `json:"content"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	AuthorName string             `json:"author_name"`
}

func (q *Queries) ListEvaluationsByStudent(ctx context.Context, arg ListEvaluationsByStudentParams) ([]ListEvaluationsByStudentRow, error) {
	rows, err := q.db.Query(ctx, listEvaluationsByStudent,
		arg.StudentID,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEvaluationsByStudentRow
	for rows.Next() {
		var i ListEvaluationsByStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.AuthorID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvaluation = `-- name: UpdateEvaluation :one
UPDATE evaluations
SET content = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, student_id, author_id, content, created_at, updated_at
`

type UpdateEvaluationParams struct {
	ID      int32  `json:"id"`
	Content string `json:"content"`
}

func (q *Queries) UpdateEvaluation(ctx context.Context, arg UpdateEvaluationParams) (Evaluation, error) {
	row := q.db.QueryRow(ctx, updateEvaluation, arg.ID, arg.Content)
	var i Evaluation
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.AuthorID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
